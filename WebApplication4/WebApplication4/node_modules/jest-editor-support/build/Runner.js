"use strict";

require("core-js/modules/es.symbol");

require("core-js/modules/es.symbol.description");

require("core-js/modules/es.symbol.iterator");

require("core-js/modules/es.array.concat");

require("core-js/modules/es.array.find");

require("core-js/modules/es.array.for-each");

require("core-js/modules/es.array.from");

require("core-js/modules/es.array.is-array");

require("core-js/modules/es.array.iterator");

require("core-js/modules/es.array.slice");

require("core-js/modules/es.date.to-string");

require("core-js/modules/es.function.name");

require("core-js/modules/es.object.create");

require("core-js/modules/es.object.define-property");

require("core-js/modules/es.object.get-prototype-of");

require("core-js/modules/es.object.set-prototype-of");

require("core-js/modules/es.object.to-string");

require("core-js/modules/es.reflect.construct");

require("core-js/modules/es.regexp.exec");

require("core-js/modules/es.regexp.to-string");

require("core-js/modules/es.string.iterator");

require("core-js/modules/es.string.replace");

require("core-js/modules/web.dom-collections.for-each");

require("core-js/modules/web.dom-collections.iterator");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _child_process = require("child_process");

var _fs = require("fs");

var _os = require("os");

var path = _interopRequireWildcard(require("path"));

var _events = _interopRequireDefault(require("events"));

var _types = require("./types");

var _project_workspace = _interopRequireDefault(require("./project_workspace"));

var _Process = require("./Process");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

function _getRequireWildcardCache() { if (typeof WeakMap !== "function") return null; var cache = new WeakMap(); _getRequireWildcardCache = function _getRequireWildcardCache() { return cache; }; return cache; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || _typeof(obj) !== "object" && typeof obj !== "function") { return { "default": obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj["default"] = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _iterableToArray(iter) { if (typeof Symbol !== "undefined" && Symbol.iterator in Object(iter)) return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function () { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

// This class represents the running process, and
// passes out events when it understands what data is being
// pass sent out of the process
var Runner = /*#__PURE__*/function (_EventEmitter) {
  _inherits(Runner, _EventEmitter);

  var _super = _createSuper(Runner);

  function Runner(workspace, options) {
    var _this;

    _classCallCheck(this, Runner);

    _this = _super.call(this);
    _this._createProcess = options && options.createProcess || _Process.createProcess;
    _this.options = options || {};
    _this.workspace = workspace;
    _this.outputPath = path.join((0, _os.tmpdir)(), "jest_runner_".concat(_this.workspace.outputFileSuffix || '', ".json"));
    _this.prevMessageTypes = [];
    return _this;
  }

  _createClass(Runner, [{
    key: "start",
    value: function start() {
      var _this2 = this;

      var watchMode = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;
      var watchAll = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

      if (this.debugprocess) {
        return;
      }

      this.watchMode = watchMode;
      this.watchAll = watchAll; // Handle the arg change on v18

      var belowEighteen = this.workspace.localJestMajorVersion < 18;
      var outputArg = belowEighteen ? '--jsonOutputFile' : '--outputFile';
      var args = ['--testLocationInResults', '--json', '--useStderr', outputArg, this.outputPath];

      if (this.watchMode) {
        args.push(this.watchAll ? '--watchAll' : '--watch');
      }

      if (this.options.testNamePattern) {
        args.push('--testNamePattern', this.options.testNamePattern);
      }

      if (this.options.testFileNamePattern) {
        args.push(this.options.testFileNamePattern);
      }

      if (this.workspace.collectCoverage === true) {
        args.push('--coverage');
      }

      if (this.workspace.collectCoverage === false) {
        args.push('--no-coverage');
      }

      if (this.options.noColor === true) {
        args.push('--no-color');
      }

      if (this.options.reporters) {
        this.options.reporters.forEach(function (reporter) {
          args.push('--reporters', reporter);
        });
      }

      this.debugprocess = this._createProcess(this.workspace, args);
      this.debugprocess.stdout.on('data', function (data) {
        _this2._parseOutput(data, false);
      });
      this.debugprocess.stderr.on('data', function (data) {
        // jest 23 could send test results message to stderr
        // see https://github.com/facebook/jest/pull/4858
        _this2._parseOutput(data, true);
      });
      this.debugprocess.on('exit', function () {
        _this2.emit('debuggerProcessExit');

        _this2.prevMessageTypes.length = 0;
      });
      this.debugprocess.on('error', function (error) {
        _this2.emit('terminalError', "Process failed: ".concat(error.message));

        _this2.prevMessageTypes.length = 0;
      });
      this.debugprocess.on('close', function () {
        _this2.emit('debuggerProcessExit');

        _this2.prevMessageTypes.length = 0;
      });
    }
    /**
     * parse the stdin/out stream buffer for recognized messages.
     *
     * note: if these messages coming in in separate chucks, we might not be able to
     * resolve it properly. While there haven't been much evidence of such scenario,
     * it's worth to note that it could and we might need to buffer them in that case.
     * see https://github.com/jest-community/jest-editor-support/pull/9#pullrequestreview-231888752
     *
     * @param {Buffer} data
     * @param {boolean} isStdErr
     * @returns {MessageType}
     * @memberof Runner
     */

  }, {
    key: "_parseOutput",
    value: function _parseOutput(data, isStdErr) {
      var _this3 = this;

      var msgType = this.findMessageType(data);

      switch (msgType) {
        case _types.messageTypes.testResults:
          (0, _fs.readFile)(this.outputPath, 'utf8', function (err, _data) {
            if (err) {
              var message = "JSON report not found at ".concat(_this3.outputPath);

              _this3.emit('terminalError', message);
            } else {
              var noTestsFound = _this3.doResultsFollowNoTestsFoundMessage();

              _this3.emit('executableJSON', JSON.parse(_data), {
                noTestsFound: noTestsFound
              });
            }
          });
          this.prevMessageTypes.length = 0;
          break;

        case _types.messageTypes.watchUsage:
        case _types.messageTypes.noTests:
          this.prevMessageTypes.push(msgType);
          this.emit('executableStdErr', data, {
            type: msgType
          });
          break;

        default:
          // no special action needed, just report the output by its source
          if (isStdErr) {
            this.emit('executableStdErr', data, {
              type: msgType
            });
          } else {
            this.emit('executableOutput', data.toString().replace('[2J[H', ''));
          }

          this.prevMessageTypes.length = 0;
          break;
      }

      return msgType;
    }
  }, {
    key: "runJestWithUpdateForSnapshots",
    value: function runJestWithUpdateForSnapshots(completion, args) {
      var defaultArgs = ['--updateSnapshot'];

      var updateProcess = this._createProcess(this.workspace, [].concat(defaultArgs, _toConsumableArray(args || [])));

      updateProcess.on('close', function () {
        completion();
      });
    }
  }, {
    key: "closeProcess",
    value: function closeProcess() {
      if (!this.debugprocess) {
        return;
      }

      if (process.platform === 'win32') {
        // Windows doesn't exit the process when it should.
        (0, _child_process.spawn)('taskkill', ['/pid', "".concat(this.debugprocess.pid), '/T', '/F']);
      } else {
        try {
          // kill all process with the same PGID, i.e.
          // as a detached process, it is the same as the PID of the leader process.
          process.kill(-this.debugprocess.pid);
        } catch (e) {
          // if anything goes wrong, fallback to the old benavior
          // knowing this could leave orphan process...
          // eslint-disable-next-line no-console
          console.warn("failed to kill process group, this could leave some orphan process whose ppid=".concat(this.debugprocess.pid, ". error="), e);
          this.debugprocess.kill();
        }
      }

      delete this.debugprocess;
    } // eslint-disable-next-line class-methods-use-this

  }, {
    key: "findMessageType",
    value: function findMessageType(buf) {
      var noTestRegex = /No tests found related to files changed since ((last commit)|("[a-z0-9]+"))./;
      var watchUsageRegex = /^\s*Watch Usage\b/;
      var testResultsRegex = /Test results written to/;
      var checks = [{
        regex: testResultsRegex,
        messageType: _types.messageTypes.testResults
      }, {
        regex: noTestRegex,
        messageType: _types.messageTypes.noTests
      }, {
        regex: watchUsageRegex,
        messageType: _types.messageTypes.watchUsage
      }];
      var str = buf.toString('utf8');
      var match = checks.find(function (_ref) {
        var regex = _ref.regex;
        return regex.test(str);
      });
      return match ? match.messageType : _types.messageTypes.unknown;
    }
  }, {
    key: "doResultsFollowNoTestsFoundMessage",
    value: function doResultsFollowNoTestsFoundMessage() {
      if (this.prevMessageTypes.length === 1) {
        return this.prevMessageTypes[0] === _types.messageTypes.noTests;
      }

      if (this.prevMessageTypes.length === 2) {
        return this.prevMessageTypes[0] === _types.messageTypes.noTests && this.prevMessageTypes[1] === _types.messageTypes.watchUsage;
      }

      return false;
    }
  }]);

  return Runner;
}(_events["default"]);

exports["default"] = Runner;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uL3NyYy9SdW5uZXIuanMiXSwibmFtZXMiOlsiUnVubmVyIiwid29ya3NwYWNlIiwib3B0aW9ucyIsIl9jcmVhdGVQcm9jZXNzIiwiY3JlYXRlUHJvY2VzcyIsIm91dHB1dFBhdGgiLCJwYXRoIiwiam9pbiIsIm91dHB1dEZpbGVTdWZmaXgiLCJwcmV2TWVzc2FnZVR5cGVzIiwid2F0Y2hNb2RlIiwid2F0Y2hBbGwiLCJkZWJ1Z3Byb2Nlc3MiLCJiZWxvd0VpZ2h0ZWVuIiwibG9jYWxKZXN0TWFqb3JWZXJzaW9uIiwib3V0cHV0QXJnIiwiYXJncyIsInB1c2giLCJ0ZXN0TmFtZVBhdHRlcm4iLCJ0ZXN0RmlsZU5hbWVQYXR0ZXJuIiwiY29sbGVjdENvdmVyYWdlIiwibm9Db2xvciIsInJlcG9ydGVycyIsImZvckVhY2giLCJyZXBvcnRlciIsInN0ZG91dCIsIm9uIiwiZGF0YSIsIl9wYXJzZU91dHB1dCIsInN0ZGVyciIsImVtaXQiLCJsZW5ndGgiLCJlcnJvciIsIm1lc3NhZ2UiLCJpc1N0ZEVyciIsIm1zZ1R5cGUiLCJmaW5kTWVzc2FnZVR5cGUiLCJtZXNzYWdlVHlwZXMiLCJ0ZXN0UmVzdWx0cyIsImVyciIsIl9kYXRhIiwibm9UZXN0c0ZvdW5kIiwiZG9SZXN1bHRzRm9sbG93Tm9UZXN0c0ZvdW5kTWVzc2FnZSIsIkpTT04iLCJwYXJzZSIsIndhdGNoVXNhZ2UiLCJub1Rlc3RzIiwidHlwZSIsInRvU3RyaW5nIiwicmVwbGFjZSIsImNvbXBsZXRpb24iLCJkZWZhdWx0QXJncyIsInVwZGF0ZVByb2Nlc3MiLCJwcm9jZXNzIiwicGxhdGZvcm0iLCJwaWQiLCJraWxsIiwiZSIsImNvbnNvbGUiLCJ3YXJuIiwiYnVmIiwibm9UZXN0UmVnZXgiLCJ3YXRjaFVzYWdlUmVnZXgiLCJ0ZXN0UmVzdWx0c1JlZ2V4IiwiY2hlY2tzIiwicmVnZXgiLCJtZXNzYWdlVHlwZSIsInN0ciIsIm1hdGNoIiwiZmluZCIsInRlc3QiLCJ1bmtub3duIiwiRXZlbnRFbWl0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Q0FDYjtBQUFDQyxRQUFBQSxLQUFLLEVBQUVGLGdCQUFSO0FBQTBCRyxRQUFBQSxXQUFXLEVBQUU3QixvQkFBYUM7QUFBcEQsT0FEYSxFQUViO0FBQUMyQixRQUFBQSxLQUFLLEVBQUVKLFdBQVI7QUFBcUJLLFFBQUFBLFdBQVcsRUFBRTdCLG9CQUFhUztBQUEvQyxPQUZhLEVBR2I7QUFBQ21CLFFBQUFBLEtBQUssRUFBRUgsZUFBUjtBQUF5QkksUUFBQUEsV0FBVyxFQUFFN0Isb0JBQWFRO0FBQW5ELE9BSGEsQ0FBZjtBQU1BLFVBQU1zQixHQUFHLEdBQUdQLEdBQUcsQ0FBQ1osUUFBSixDQUFhLE1BQWIsQ0FBWjtBQUNBLFVBQU1vQixLQUFLLEdBQUdKLE1BQU0sQ0FBQ0ssSUFBUCxDQUFZO0FBQUEsWUFBRUosS0FBRixRQUFFQSxLQUFGO0FBQUEsZUFBYUEsS0FBSyxDQUFDSyxJQUFOLENBQVdILEdBQVgsQ0FBYjtBQUFBLE9BQVosQ0FBZDtBQUNBLGFBQU9DLEtBQUssR0FBR0EsS0FBSyxDQUFDRixXQUFULEdBQXVCN0Isb0JBQWFrQyxPQUFoRDtBQUNEOzs7eURBRW9DO0FBQ25DLFVBQUksS0FBSzlELGdCQUFMLENBQXNCc0IsTUFBdEIsS0FBaUMsQ0FBckMsRUFBd0M7QUFDdEMsZUFBTyxLQUFLdEIsZ0JBQUwsQ0FBc0IsQ0FBdEIsTUFBNkI0QixvQkFBYVMsT0FBakQ7QUFDRDs7QUFFRCxVQUFJLEtBQUtyQyxnQkFBTCxDQUFzQnNCLE1BQXRCLEtBQWlDLENBQXJDLEVBQXdDO0FBQ3RDLGVBQU8sS0FBS3RCLGdCQUFMLENBQXNCLENBQXRCLE1BQTZCNEIsb0JBQWFTLE9BQTFDLElBQXFELEtBQUtyQyxnQkFBTCxDQUFzQixDQUF0QixNQUE2QjRCLG9CQUFhUSxVQUF0RztBQUNEOztBQUVELGFBQU8sS0FBUDtBQUNEOzs7O0VBN01pQzJCLGtCIiwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTQtcHJlc2VudCwgRmFjZWJvb2ssIEluYy4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKiBAZmxvd1xuICovXG5cbmltcG9ydCB7Q2hpbGRQcm9jZXNzLCBzcGF3bn0gZnJvbSAnY2hpbGRfcHJvY2Vzcyc7XG5pbXBvcnQge3JlYWRGaWxlfSBmcm9tICdmcyc7XG5pbXBvcnQge3RtcGRpcn0gZnJvbSAnb3MnO1xuaW1wb3J0ICogYXMgcGF0aCBmcm9tICdwYXRoJztcbmltcG9ydCBFdmVudEVtaXR0ZXIgZnJvbSAnZXZlbnRzJztcbmltcG9ydCB7bWVzc2FnZVR5cGVzfSBmcm9tICcuL3R5cGVzJztcbmltcG9ydCB0eXBlIHtPcHRpb25zLCBNZXNzYWdlVHlwZX0gZnJvbSAnLi90eXBlcyc7XG5pbXBvcnQgUHJvamVjdFdvcmtzcGFjZSBmcm9tICcuL3Byb2plY3Rfd29ya3NwYWNlJztcbmltcG9ydCB7Y3JlYXRlUHJvY2Vzc30gZnJvbSAnLi9Qcm9jZXNzJztcblxuLy8gVGhpcyBjbGFzcyByZXByZXNlbnRzIHRoZSBydW5uaW5nIHByb2Nlc3MsIGFuZFxuLy8gcGFzc2VzIG91dCBldmVudHMgd2hlbiBpdCB1bmRlcnN0YW5kcyB3aGF0IGRhdGEgaXMgYmVpbmdcbi8vIHBhc3Mgc2VudCBvdXQgb2YgdGhlIHByb2Nlc3NcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFJ1bm5lciBleHRlbmRzIEV2ZW50RW1pdHRlciB7XG4gIGRlYnVncHJvY2VzczogQ2hpbGRQcm9jZXNzO1xuXG4gIG91dHB1dFBhdGg6IHN0cmluZztcblxuICB3b3Jrc3BhY2U6IFByb2plY3RXb3Jrc3BhY2U7XG5cbiAgX2NyZWF0ZVByb2Nlc3M6ICh3b3Jrc3BhY2U6IFByb2plY3RXb3Jrc3BhY2UsIGFyZ3M6IEFycmF5PHN0cmluZz4pID0+IENoaWxkUHJvY2VzcztcblxuICB3YXRjaE1vZGU6IGJvb2xlYW47XG5cbiAgd2F0Y2hBbGw6IGJvb2xlYW47XG5cbiAgb3B0aW9uczogT3B0aW9ucztcblxuICBwcmV2TWVzc2FnZVR5cGVzOiBNZXNzYWdlVHlwZVtdO1xuXG4gIGNvbnN0cnVjdG9yKHdvcmtzcGFjZTogUHJvamVjdFdvcmtzcGFjZSwgb3B0aW9ucz86IE9wdGlvbnMpIHtcbiAgICBzdXBlcigpO1xuXG4gICAgdGhpcy5fY3JlYXRlUHJvY2VzcyA9IChvcHRpb25zICYmIG9wdGlvbnMuY3JlYXRlUHJvY2VzcykgfHwgY3JlYXRlUHJvY2VzcztcbiAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICAgIHRoaXMud29ya3NwYWNlID0gd29ya3NwYWNlO1xuICAgIHRoaXMub3V0cHV0UGF0aCA9IHBhdGguam9pbih0bXBkaXIoKSwgYGplc3RfcnVubmVyXyR7dGhpcy53b3Jrc3BhY2Uub3V0cHV0RmlsZVN1ZmZpeCB8fCAnJ30uanNvbmApO1xuICAgIHRoaXMucHJldk1lc3NhZ2VUeXBlcyA9IFtdO1xuICB9XG5cbiAgc3RhcnQod2F0Y2hNb2RlOiBib29sZWFuID0gdHJ1ZSwgd2F0Y2hBbGw6IGJvb2xlYW4gPSBmYWxzZSkge1xuICAgIGlmICh0aGlzLmRlYnVncHJvY2Vzcykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHRoaXMud2F0Y2hNb2RlID0gd2F0Y2hNb2RlO1xuICAgIHRoaXMud2F0Y2hBbGwgPSB3YXRjaEFsbDtcblxuICAgIC8vIEhhbmRsZSB0aGUgYXJnIGNoYW5nZSBvbiB2MThcbiAgICBjb25zdCBiZWxvd0VpZ2h0ZWVuID0gdGhpcy53b3Jrc3BhY2UubG9jYWxKZXN0TWFqb3JWZXJzaW9uIDwgMTg7XG4gICAgY29uc3Qgb3V0cHV0QXJnID0gYmVsb3dFaWdodGVlbiA/ICctLWpzb25PdXRwdXRGaWxlJyA6ICctLW91dHB1dEZpbGUnO1xuXG4gICAgY29uc3QgYXJncyA9IFsnLS10ZXN0TG9jYXRpb25JblJlc3VsdHMnLCAnLS1qc29uJywgJy0tdXNlU3RkZXJyJywgb3V0cHV0QXJnLCB0aGlzLm91dHB1dFBhdGhdO1xuICAgIGlmICh0aGlzLndhdGNoTW9kZSkge1xuICAgICAgYXJncy5wdXNoKHRoaXMud2F0Y2hBbGwgPyAnLS13YXRjaEFsbCcgOiAnLS13YXRjaCcpO1xuICAgIH1cbiAgICBpZiAodGhpcy5vcHRpb25zLnRlc3ROYW1lUGF0dGVybikge1xuICAgICAgYXJncy5wdXNoKCctLXRlc3ROYW1lUGF0dGVybicsIHRoaXMub3B0aW9ucy50ZXN0TmFtZVBhdHRlcm4pO1xuICAgIH1cbiAgICBpZiAodGhpcy5vcHRpb25zLnRlc3RGaWxlTmFtZVBhdHRlcm4pIHtcbiAgICAgIGFyZ3MucHVzaCh0aGlzLm9wdGlvbnMudGVzdEZpbGVOYW1lUGF0dGVybik7XG4gICAgfVxuICAgIGlmICh0aGlzLndvcmtzcGFjZS5jb2xsZWN0Q292ZXJhZ2UgPT09IHRydWUpIHtcbiAgICAgIGFyZ3MucHVzaCgnLS1jb3ZlcmFnZScpO1xuICAgIH1cbiAgICBpZiAodGhpcy53b3Jrc3BhY2UuY29sbGVjdENvdmVyYWdlID09PSBmYWxzZSkge1xuICAgICAgYXJncy5wdXNoKCctLW5vLWNvdmVyYWdlJyk7XG4gICAgfVxuICAgIGlmICh0aGlzLm9wdGlvbnMubm9Db2xvciA9PT0gdHJ1ZSkge1xuICAgICAgYXJncy5wdXNoKCctLW5vLWNvbG9yJyk7XG4gICAgfVxuICAgIGlmICh0aGlzLm9wdGlvbnMucmVwb3J0ZXJzKSB7XG4gICAgICB0aGlzLm9wdGlvbnMucmVwb3J0ZXJzLmZvckVhY2gocmVwb3J0ZXIgPT4ge1xuICAgICAgICBhcmdzLnB1c2goJy0tcmVwb3J0ZXJzJywgcmVwb3J0ZXIpO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgdGhpcy5kZWJ1Z3Byb2Nlc3MgPSB0aGlzLl9jcmVhdGVQcm9jZXNzKHRoaXMud29ya3NwYWNlLCBhcmdzKTtcbiAgICB0aGlzLmRlYnVncHJvY2Vzcy5zdGRvdXQub24oJ2RhdGEnLCAoZGF0YTogQnVmZmVyKSA9PiB7XG4gICAgICB0aGlzLl9wYXJzZU91dHB1dChkYXRhLCBmYWxzZSk7XG4gICAgfSk7XG5cbiAgICB0aGlzLmRlYnVncHJvY2Vzcy5zdGRlcnIub24oJ2RhdGEnLCAoZGF0YTogQnVmZmVyKSA9PiB7XG4gICAgICAvLyBqZXN0IDIzIGNvdWxkIHNlbmQgdGVzdCByZXN1bHRzIG1lc3NhZ2UgdG8gc3RkZXJyXG4gICAgICAvLyBzZWUgaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL2plc3QvcHVsbC80ODU4XG4gICAgICB0aGlzLl9wYXJzZU91dHB1dChkYXRhLCB0cnVlKTtcbiAgICB9KTtcbiAgICB0aGlzLmRlYnVncHJvY2Vzcy5vbignZXhpdCcsICgpID0+IHtcbiAgICAgIHRoaXMuZW1pdCgnZGVidWdnZXJQcm9jZXNzRXhpdCcpO1xuICAgICAgdGhpcy5wcmV2TWVzc2FnZVR5cGVzLmxlbmd0aCA9IDA7XG4gICAgfSk7XG5cbiAgICB0aGlzLmRlYnVncHJvY2Vzcy5vbignZXJyb3InLCAoZXJyb3I6IEVycm9yKSA9PiB7XG4gICAgICB0aGlzLmVtaXQoJ3Rlcm1pbmFsRXJyb3InLCBgUHJvY2VzcyBmYWlsZWQ6ICR7ZXJyb3IubWVzc2FnZX1gKTtcbiAgICAgIHRoaXMucHJldk1lc3NhZ2VUeXBlcy5sZW5ndGggPSAwO1xuICAgIH0pO1xuXG4gICAgdGhpcy5kZWJ1Z3Byb2Nlc3Mub24oJ2Nsb3NlJywgKCkgPT4ge1xuICAgICAgdGhpcy5lbWl0KCdkZWJ1Z2dlclByb2Nlc3NFeGl0Jyk7XG4gICAgICB0aGlzLnByZXZNZXNzYWdlVHlwZXMubGVuZ3RoID0gMDtcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBwYXJzZSB0aGUgc3RkaW4vb3V0IHN0cmVhbSBidWZmZXIgZm9yIHJlY29nbml6ZWQgbWVzc2FnZXMuXG4gICAqXG4gICAqIG5vdGU6IGlmIHRoZXNlIG1lc3NhZ2VzIGNvbWluZyBpbiBpbiBzZXBhcmF0ZSBjaHVja3MsIHdlIG1pZ2h0IG5vdCBiZSBhYmxlIHRvXG4gICAqIHJlc29sdmUgaXQgcHJvcGVybHkuIFdoaWxlIHRoZXJlIGhhdmVuJ3QgYmVlbiBtdWNoIGV2aWRlbmNlIG9mIHN1Y2ggc2NlbmFyaW8sXG4gICAqIGl0J3Mgd29ydGggdG8gbm90ZSB0aGF0IGl0IGNvdWxkIGFuZCB3ZSBtaWdodCBuZWVkIHRvIGJ1ZmZlciB0aGVtIGluIHRoYXQgY2FzZS5cbiAgICogc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9qZXN0LWNvbW11bml0eS9qZXN0LWVkaXRvci1zdXBwb3J0L3B1bGwvOSNwdWxscmVxdWVzdHJldmlldy0yMzE4ODg3NTJcbiAgICpcbiAgICogQHBhcmFtIHtCdWZmZXJ9IGRhdGFcbiAgICogQHBhcmFtIHtib29sZWFufSBpc1N0ZEVyclxuICAgKiBAcmV0dXJucyB7TWVzc2FnZVR5cGV9XG4gICAqIEBtZW1iZXJvZiBSdW5uZXJcbiAgICovXG4gIF9wYXJzZU91dHB1dChkYXRhOiBCdWZmZXIsIGlzU3RkRXJyOiBib29sZWFuKTogTWVzc2FnZVR5cGUge1xuICAgIGNvbnN0IG1zZ1R5cGUgPSB0aGlzLmZpbmRNZXNzYWdlVHlwZShkYXRhKTtcbiAgICBzd2l0Y2ggKG1zZ1R5cGUpIHtcbiAgICAgIGNhc2UgbWVzc2FnZVR5cGVzLnRlc3RSZXN1bHRzOlxuICAgICAgICByZWFkRmlsZSh0aGlzLm91dHB1dFBhdGgsICd1dGY4JywgKGVyciwgX2RhdGEpID0+IHtcbiAgICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgICBjb25zdCBtZXNzYWdlID0gYEpTT04gcmVwb3J0IG5vdCBmb3VuZCBhdCAke3RoaXMub3V0cHV0UGF0aH1gO1xuICAgICAgICAgICAgdGhpcy5lbWl0KCd0ZXJtaW5hbEVycm9yJywgbWVzc2FnZSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IG5vVGVzdHNGb3VuZCA9IHRoaXMuZG9SZXN1bHRzRm9sbG93Tm9UZXN0c0ZvdW5kTWVzc2FnZSgpO1xuICAgICAgICAgICAgdGhpcy5lbWl0KCdleGVjdXRhYmxlSlNPTicsIEpTT04ucGFyc2UoX2RhdGEpLCB7XG4gICAgICAgICAgICAgIG5vVGVzdHNGb3VuZCxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMucHJldk1lc3NhZ2VUeXBlcy5sZW5ndGggPSAwO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgbWVzc2FnZVR5cGVzLndhdGNoVXNhZ2U6XG4gICAgICBjYXNlIG1lc3NhZ2VUeXBlcy5ub1Rlc3RzOlxuICAgICAgICB0aGlzLnByZXZNZXNzYWdlVHlwZXMucHVzaChtc2dUeXBlKTtcbiAgICAgICAgdGhpcy5lbWl0KCdleGVjdXRhYmxlU3RkRXJyJywgZGF0YSwge1xuICAgICAgICAgIHR5cGU6IG1zZ1R5cGUsXG4gICAgICAgIH0pO1xuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIC8vIG5vIHNwZWNpYWwgYWN0aW9uIG5lZWRlZCwganVzdCByZXBvcnQgdGhlIG91dHB1dCBieSBpdHMgc291cmNlXG4gICAgICAgIGlmIChpc1N0ZEVycikge1xuICAgICAgICAgIHRoaXMuZW1pdCgnZXhlY3V0YWJsZVN0ZEVycicsIGRhdGEsIHtcbiAgICAgICAgICAgIHR5cGU6IG1zZ1R5cGUsXG4gICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5lbWl0KCdleGVjdXRhYmxlT3V0cHV0JywgZGF0YS50b1N0cmluZygpLnJlcGxhY2UoJ1x1MDAxYlsySlx1MDAxYltIJywgJycpKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnByZXZNZXNzYWdlVHlwZXMubGVuZ3RoID0gMDtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuXG4gICAgcmV0dXJuIG1zZ1R5cGU7XG4gIH1cblxuICBydW5KZXN0V2l0aFVwZGF0ZUZvclNuYXBzaG90cyhjb21wbGV0aW9uOiAoKSA9PiB2b2lkLCBhcmdzPzogc3RyaW5nW10pIHtcbiAgICBjb25zdCBkZWZhdWx0QXJncyA9IFsnLS11cGRhdGVTbmFwc2hvdCddO1xuXG4gICAgY29uc3QgdXBkYXRlUHJvY2VzcyA9IHRoaXMuX2NyZWF0ZVByb2Nlc3ModGhpcy53b3Jrc3BhY2UsIFsuLi5kZWZhdWx0QXJncywgLi4uKGFyZ3MgfHwgW10pXSk7XG4gICAgdXBkYXRlUHJvY2Vzcy5vbignY2xvc2UnLCAoKSA9PiB7XG4gICAgICBjb21wbGV0aW9uKCk7XG4gICAgfSk7XG4gIH1cblxuICBjbG9zZVByb2Nlc3MoKSB7XG4gICAgaWYgKCF0aGlzLmRlYnVncHJvY2Vzcykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAocHJvY2Vzcy5wbGF0Zm9ybSA9PT0gJ3dpbjMyJykge1xuICAgICAgLy8gV2luZG93cyBkb2Vzbid0IGV4aXQgdGhlIHByb2Nlc3Mgd2hlbiBpdCBzaG91bGQuXG4gICAgICBzcGF3bigndGFza2tpbGwnLCBbJy9waWQnLCBgJHt0aGlzLmRlYnVncHJvY2Vzcy5waWR9YCwgJy9UJywgJy9GJ10pO1xuICAgIH0gZWxzZSB7XG4gICAgICB0cnkge1xuICAgICAgICAvLyBraWxsIGFsbCBwcm9jZXNzIHdpdGggdGhlIHNhbWUgUEdJRCwgaS5lLlxuICAgICAgICAvLyBhcyBhIGRldGFjaGVkIHByb2Nlc3MsIGl0IGlzIHRoZSBzYW1lIGFzIHRoZSBQSUQgb2YgdGhlIGxlYWRlciBwcm9jZXNzLlxuICAgICAgICBwcm9jZXNzLmtpbGwoLXRoaXMuZGVidWdwcm9jZXNzLnBpZCk7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIC8vIGlmIGFueXRoaW5nIGdvZXMgd3JvbmcsIGZhbGxiYWNrIHRvIHRoZSBvbGQgYmVuYXZpb3JcbiAgICAgICAgLy8ga25vd2luZyB0aGlzIGNvdWxkIGxlYXZlIG9ycGhhbiBwcm9jZXNzLi4uXG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1jb25zb2xlXG4gICAgICAgIGNvbnNvbGUud2FybihcbiAgICAgICAgICBgZmFpbGVkIHRvIGtpbGwgcHJvY2VzcyBncm91cCwgdGhpcyBjb3VsZCBsZWF2ZSBzb21lIG9ycGhhbiBwcm9jZXNzIHdob3NlIHBwaWQ9JHt0aGlzLmRlYnVncHJvY2Vzcy5waWR9LiBlcnJvcj1gLFxuICAgICAgICAgIGVcbiAgICAgICAgKTtcbiAgICAgICAgdGhpcy5kZWJ1Z3Byb2Nlc3Mua2lsbCgpO1xuICAgICAgfVxuICAgIH1cbiAgICBkZWxldGUgdGhpcy5kZWJ1Z3Byb2Nlc3M7XG4gIH1cblxuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgY2xhc3MtbWV0aG9kcy11c2UtdGhpc1xuICBmaW5kTWVzc2FnZVR5cGUoYnVmOiBCdWZmZXIpOiBNZXNzYWdlVHlwZSB7XG4gICAgY29uc3Qgbm9UZXN0UmVnZXggPSAvTm8gdGVzdHMgZm91bmQgcmVsYXRlZCB0byBmaWxlcyBjaGFuZ2VkIHNpbmNlICgobGFzdCBjb21taXQpfChcIlthLXowLTldK1wiKSkuLztcbiAgICBjb25zdCB3YXRjaFVzYWdlUmVnZXggPSAvXlxccypXYXRjaCBVc2FnZVxcYi87XG4gICAgY29uc3QgdGVzdFJlc3VsdHNSZWdleCA9IC9UZXN0IHJlc3VsdHMgd3JpdHRlbiB0by87XG5cbiAgICBjb25zdCBjaGVja3MgPSBbXG4gICAgICB7cmVnZXg6IHRlc3RSZXN1bHRzUmVnZXgsIG1lc3NhZ2VUeXBlOiBtZXNzYWdlVHlwZXMudGVzdFJlc3VsdHN9LFxuICAgICAge3JlZ2V4OiBub1Rlc3RSZWdleCwgbWVzc2FnZVR5cGU6IG1lc3NhZ2VUeXBlcy5ub1Rlc3RzfSxcbiAgICAgIHtyZWdleDogd2F0Y2hVc2FnZVJlZ2V4LCBtZXNzYWdlVHlwZTogbWVzc2FnZVR5cGVzLndhdGNoVXNhZ2V9LFxuICAgIF07XG5cbiAgICBjb25zdCBzdHIgPSBidWYudG9TdHJpbmcoJ3V0ZjgnKTtcbiAgICBjb25zdCBtYXRjaCA9IGNoZWNrcy5maW5kKCh7cmVnZXh9KSA9PiByZWdleC50ZXN0KHN0cikpO1xuICAgIHJldHVybiBtYXRjaCA/IG1hdGNoLm1lc3NhZ2VUeXBlIDogbWVzc2FnZVR5cGVzLnVua25vd247XG4gIH1cblxuICBkb1Jlc3VsdHNGb2xsb3dOb1Rlc3RzRm91bmRNZXNzYWdlKCkge1xuICAgIGlmICh0aGlzLnByZXZNZXNzYWdlVHlwZXMubGVuZ3RoID09PSAxKSB7XG4gICAgICByZXR1cm4gdGhpcy5wcmV2TWVzc2FnZVR5cGVzWzBdID09PSBtZXNzYWdlVHlwZXMubm9UZXN0cztcbiAgICB9XG5cbiAgICBpZiAodGhpcy5wcmV2TWVzc2FnZVR5cGVzLmxlbmd0aCA9PT0gMikge1xuICAgICAgcmV0dXJuIHRoaXMucHJldk1lc3NhZ2VUeXBlc1swXSA9PT0gbWVzc2FnZVR5cGVzLm5vVGVzdHMgJiYgdGhpcy5wcmV2TWVzc2FnZVR5cGVzWzFdID09PSBtZXNzYWdlVHlwZXMud2F0Y2hVc2FnZTtcbiAgICB9XG5cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn1cbiJdfQ==