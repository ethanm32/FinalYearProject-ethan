"use strict";

require("core-js/modules/es.array.find");

require("core-js/modules/es.array.for-each");

require("core-js/modules/es.array.includes");

require("core-js/modules/es.array.join");

require("core-js/modules/es.array.map");

require("core-js/modules/es.array.splice");

require("core-js/modules/es.function.name");

require("core-js/modules/es.object.define-property");

require("core-js/modules/es.parse-int");

require("core-js/modules/es.regexp.exec");

require("core-js/modules/es.string.includes");

require("core-js/modules/es.string.replace");

require("core-js/modules/es.string.split");

require("core-js/modules/es.string.trim");

require("core-js/modules/web.dom-collections.for-each");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _path = _interopRequireDefault(require("path"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

/**
 *  You have a Jest test runner watching for changes, and you have
 *  an extension that wants to know where to show errors after file parsing.
 *
 *  This class represents the state between runs, keeping track of passes/fails
 *  at a file level, generating useful error messages and providing a nice API.
 */
var TestReconciler = /*#__PURE__*/function () {
  function TestReconciler() {
    _classCallCheck(this, TestReconciler);

    this.fileStatuses = {};
  } // the processed test results will be returned immediately instead of saved in
  // instance properties. This is 1) to prevent race condition 2) the data is already
  // stored in the this.fileStatuses, no dup is better 3) client will most likely need to process
  // all the results anyway.


  _createClass(TestReconciler, [{
    key: "updateFileWithJestStatus",
    value: function updateFileWithJestStatus(results) {
      var _this = this;

      // Loop through all files inside the report from Jest
      var statusList = [];
      results.testResults.forEach(function (file) {
        // Did the file pass/fail?
        var status = _this.statusToReconcilationState(file.status); // Create our own simpler representation


        var fileStatus = {
          assertions: _this.mapAssertions(file.name, file.assertionResults),
          file: file.name,
          message: file.message,
          status: status
        };
        _this.fileStatuses[file.name] = fileStatus;
        statusList.push(fileStatus);
      });
      return statusList;
    } // A failed test also contains the stack trace for an `expect`
    // we don't get this as structured data, but what we get
    // is useful enough to make it for ourselves

  }, {
    key: "mapAssertions",
    value: function mapAssertions(filename, assertions) {
      var _this2 = this;

      // convert jest location (column is 0-based and line is 1-based) to all 0-based location used internally in this package

      /* eslint-disable no-param-reassign */
      var convertJestLocation = function convertJestLocation(jestLocation) {
        if (jestLocation) {
          jestLocation.line -= 1;
        }

        return jestLocation;
      }; // Is it jest < 17? e.g. Before I added this to the JSON


      if (!assertions) {
        return [];
      } // Change all failing assertions into structured data


      return assertions.map(function (assertion) {
        // Failure messages seems to always be an array of one item
        var message = assertion.failureMessages && assertion.failureMessages[0];
        var _short = null;
        var terse = null;
        var line = null;
        var location = convertJestLocation(assertion.location); // output from jest --testLocationInResults (https://jestjs.io/docs/en/cli#testlocationinresults)

        if (message) {
          // Just the first line, with little whitespace
          _short = message.split('   at', 1)[0].trim(); // this will show inline, so we want to show very little

          terse = _this2.sanitizeShortErrorMessage(_short);
          line = _this2.lineOfError(message, filename);
        }

        return {
          line: line,
          message: message || '',
          shortMessage: _short,
          status: _this2.statusToReconcilationState(assertion.status),
          terseMessage: terse,
          title: assertion.title,
          location: location,
          fullName: assertion.fullName,
          ancestorTitles: assertion.ancestorTitles
        };
      });
    } // Do everything we can to try make a one-liner from the error report

  }, {
    key: "sanitizeShortErrorMessage",
    value: function sanitizeShortErrorMessage(string) {
      if (string.includes('does not match stored snapshot')) {
        return 'Snapshot has changed';
      }

      if (string.includes('New snapshot was not written')) {
        return 'New snapshot is ready to write';
      }

      return string.split('\n').splice(2).join('').replace(/\s\s+/g, ' ').replace('Received:', ', Received:').split('Difference:')[0];
    } // Pull the line out from the stack trace

  }, {
    key: "lineOfError",
    value: function lineOfError(message, filePath) {
      var filename = _path["default"].basename(filePath);

      var restOfTrace = message.split(filename, 2)[1];
      return restOfTrace ? parseInt(restOfTrace.split(':')[1], 10) : null;
    }
  }, {
    key: "statusToReconcilationState",
    value: function statusToReconcilationState(status) {
      switch (status) {
        case 'passed':
          return 'KnownSuccess';

        case 'failed':
          return 'KnownFail';

        case 'pending':
          return 'KnownSkip';

        default:
          return 'Unknown';
      }
    }
  }, {
    key: "stateForTestFile",
    value: function stateForTestFile(file) {
      var results = this.fileStatuses[file];

      if (!results) {
        return 'Unknown';
      }

      return results.status;
    }
  }, {
    key: "assertionsForTestFile",
    value: function assertionsForTestFile(file) {
      var results = this.fileStatuses[file];
      return results ? results.assertions : null;
    }
  }, {
    key: "stateForTestAssertion",
    value: function stateForTestAssertion(file, name) {
      var results = this.fileStatuses[file];

      if (!results || !results.assertions) {
        return null;
      }

      var assertion = results.assertions.find(function (a) {
        return a.title === name;
      });

      if (!assertion) {
        return null;
      }

      return assertion;
    }
  }]);

  return TestReconciler;
}();

exports["default"] = TestReconciler;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uL3NyYy90ZXN0X3JlY29uY2lsZXIuanMiXSwibmFtZXMiOlsiVGVzdFJlY29uY2lsZXIiLCJmaWxlU3RhdHVzZXMiLCJyZXN1bHRzIiwic3RhdHVzTGlzdCIsInRlc3RSZXN1bHRzIiwiZm9yRWFjaCIsImZpbGUiLCJzdGF0dXMiLCJzdGF0dXNUb1JlY29uY2lsYXRpb25TdGF0ZSIsImZpbGVTdGF0dXMiLCJhc3NlcnRpb25zIiwibWFwQXNzZXJ0aW9ucyIsIm5hbWUiLCJhc3NlcnRpb25SZXN1bHRzIiwibWVzc2FnZSIsInB1c2giLCJmaWxlbmFtZSIsImNvbnZlcnRKZXN0TG9jYXRpb24iLCJqZXN0TG9jYXRpb24iLCJsaW5lIiwibWFwIiwiYXNzZXJ0aW9uIiwiZmFpbHVyZU1lc3NhZ2VzIiwic2hvcnQiLCJ0ZXJzZSIsImxvY2F0aW9uIiwic3BsaXQiLCJ0cmltIiwic2FuaXRpemVTaG9ydEVycm9yTWVzc2FnZSIsImxpbmVPZkVycm9yIiwic2hvcnRNZXNzYWdlIiwidGVyc2VNZXNzYWdlIiwidGl0bGUiLCJmdWxsTmFtZSIsImFuY2VzdG9yVGl0bGVzIiwic3RyaW5nIiwiaW5jbHVkZXMiLCJzcGxpY2UiLCJqb2luIiwicmVwbGFjZSIsImZpbGVQYXRoIiwicGF0aCIsImJhc2VuYW1lIiwicmVzdE9mVHJhY2UiLCJwYXJzZUludCIsImZpbmQiLCJhIl0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBVUE7Ozs7Ozs7Ozs7QUFLQTs7Ozs7OztJQU9xQkEsYztBQUduQiw0QkFBYztBQUFBOztBQUNaLFNBQUtDLFlBQUwsR0FBb0IsRUFBcEI7QUFDRCxHLENBRUQ7QUFDQTtBQUNBO0FBQ0E7Ozs7OzZDQUN5QkMsTyxFQUEwRDtBQUFBOztBQUNqRjtBQUNBLFVBQU1DLFVBQXFDLEdBQUcsRUFBOUM7QUFDQUQsTUFBQUEsT0FBTyxDQUFDRSxXQUFSLENBQW9CQyxPQUFwQixDQUE0QixVQUFBQyxJQUFJLEVB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T0osT0FBTyxHQUFHQSxPQUFPLENBQUNRLFVBQVgsR0FBd0IsSUFBdEM7QUFDRDs7OzBDQUVxQkosSSxFQUFjTSxJLEVBQTBDO0FBQzVFLFVBQU1WLE9BQU8sR0FBRyxLQUFLRCxZQUFMLENBQWtCSyxJQUFsQixDQUFoQjs7QUFDQSxVQUFJLENBQUNKLE9BQUQsSUFBWSxDQUFDQSxPQUFPLENBQUNRLFVBQXpCLEVBQXFDO0FBQ25DLGVBQU8sSUFBUDtBQUNEOztBQUNELFVBQU1XLFNBQVMsR0FBR25CLE9BQU8sQ0FBQ1EsVUFBUixDQUFtQm1DLElBQW5CLENBQXdCLFVBQUFDLENBQUM7QUFBQSxlQUFJQSxDQUFDLENBQUNkLEtBQUYsS0FBWXBCLElBQWhCO0FBQUEsT0FBekIsQ0FBbEI7O0FBQ0EsVUFBSSxDQUFDUyxTQUFMLEVBQWdCO0FBQ2QsZUFBTyxJQUFQO0FBQ0Q7O0FBQ0QsYUFBT0EsU0FBUDtBQUNEIiwic291cmNlc0NvbnRlbnQiOlsiLyogZXNsaW50LWRpc2FibGUgY2xhc3MtbWV0aG9kcy11c2UtdGhpcyAqL1xuLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTQtcHJlc2VudCwgRmFjZWJvb2ssIEluYy4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKiBAZmxvd1xuICovXG5cbmltcG9ydCBwYXRoIGZyb20gJ3BhdGgnO1xuaW1wb3J0IHR5cGUge1Rlc3RGaWxlQXNzZXJ0aW9uU3RhdHVzLCBUZXN0QXNzZXJ0aW9uU3RhdHVzLCBUZXN0UmVjb25jaWxpYXRpb25TdGF0ZSwgTG9jYXRpb259IGZyb20gJy4vdHlwZXMnO1xuXG5pbXBvcnQgdHlwZSB7Rm9ybWF0dGVkQXNzZXJ0aW9uUmVzdWx0LCBGb3JtYXR0ZWRUZXN0UmVzdWx0c30gZnJvbSAnLi4vdHlwZXMvVGVzdFJlc3VsdCc7XG5cbi8qKlxuICogIFlvdSBoYXZlIGEgSmVzdCB0ZXN0IHJ1bm5lciB3YXRjaGluZyBmb3IgY2hhbmdlcywgYW5kIHlvdSBoYXZlXG4gKiAgYW4gZXh0ZW5zaW9uIHRoYXQgd2FudHMgdG8ga25vdyB3aGVyZSB0byBzaG93IGVycm9ycyBhZnRlciBmaWxlIHBhcnNpbmcuXG4gKlxuICogIFRoaXMgY2xhc3MgcmVwcmVzZW50cyB0aGUgc3RhdGUgYmV0d2VlbiBydW5zLCBrZWVwaW5nIHRyYWNrIG9mIHBhc3Nlcy9mYWlsc1xuICogIGF0IGEgZmlsZSBsZXZlbCwgZ2VuZXJhdGluZyB1c2VmdWwgZXJyb3IgbWVzc2FnZXMgYW5kIHByb3ZpZGluZyBhIG5pY2UgQVBJLlxuICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBUZXN0UmVjb25jaWxlciB7XG4gIGZpbGVTdGF0dXNlczoge1trZXk6IHN0cmluZ106IFRlc3RGaWxlQXNzZXJ0aW9uU3RhdHVzfTtcblxuICBjb25zdHJ1Y3RvcigpIHtcbiAgICB0aGlzLmZpbGVTdGF0dXNlcyA9IHt9O1xuICB9XG5cbiAgLy8gdGhlIHByb2Nlc3NlZCB0ZXN0IHJlc3VsdHMgd2lsbCBiZSByZXR1cm5lZCBpbW1lZGlhdGVseSBpbnN0ZWFkIG9mIHNhdmVkIGluXG4gIC8vIGluc3RhbmNlIHByb3BlcnRpZXMuIFRoaXMgaXMgMSkgdG8gcHJldmVudCByYWNlIGNvbmRpdGlvbiAyKSB0aGUgZGF0YSBpcyBhbHJlYWR5XG4gIC8vIHN0b3JlZCBpbiB0aGUgdGhpcy5maWxlU3RhdHVzZXMsIG5vIGR1cCBpcyBiZXR0ZXIgMykgY2xpZW50IHdpbGwgbW9zdCBsaWtlbHkgbmVlZCB0byBwcm9jZXNzXG4gIC8vIGFsbCB0aGUgcmVzdWx0cyBhbnl3YXkuXG4gIHVwZGF0ZUZpbGVXaXRoSmVzdFN0YXR1cyhyZXN1bHRzOiBGb3JtYXR0ZWRUZXN0UmVzdWx0cyk6IFRlc3RGaWxlQXNzZXJ0aW9uU3RhdHVzW10ge1xuICAgIC8vIExvb3AgdGhyb3VnaCBhbGwgZmlsZXMgaW5zaWRlIHRoZSByZXBvcnQgZnJvbSBKZXN0XG4gICAgY29uc3Qgc3RhdHVzTGlzdDogVGVzdEZpbGVBc3NlcnRpb25TdGF0dXNbXSA9IFtdO1xuICAgIHJlc3VsdHMudGVzdFJlc3VsdHMuZm9yRWFjaChmaWxlID0+IHtcbiAgICAgIC8vIERpZCB0aGUgZmlsZSBwYXNzL2ZhaWw/XG4gICAgICBjb25zdCBzdGF0dXMgPSB0aGlzLnN0YXR1c1RvUmVjb25jaWxhdGlvblN0YXRlKGZpbGUuc3RhdHVzKTtcbiAgICAgIC8vIENyZWF0ZSBvdXIgb3duIHNpbXBsZXIgcmVwcmVzZW50YXRpb25cbiAgICAgIGNvbnN0IGZpbGVTdGF0dXM6IFRlc3RGaWxlQXNzZXJ0aW9uU3RhdHVzID0ge1xuICAgICAgICBhc3NlcnRpb25zOiB0aGlzLm1hcEFzc2VydGlvbnMoZmlsZS5uYW1lLCBmaWxlLmFzc2VydGlvblJlc3VsdHMpLFxuICAgICAgICBmaWxlOiBmaWxlLm5hbWUsXG4gICAgICAgIG1lc3NhZ2U6IGZpbGUubWVzc2FnZSxcbiAgICAgICAgc3RhdHVzLFxuICAgICAgfTtcbiAgICAgIHRoaXMuZmlsZVN0YXR1c2VzW2ZpbGUubmFtZV0gPSBmaWxlU3RhdHVzO1xuICAgICAgc3RhdHVzTGlzdC5wdXNoKGZpbGVTdGF0dXMpO1xuICAgIH0pO1xuICAgIHJldHVybiBzdGF0dXNMaXN0O1xuICB9XG5cbiAgLy8gQSBmYWlsZWQgdGVzdCBhbHNvIGNvbnRhaW5zIHRoZSBzdGFjayB0cmFjZSBmb3IgYW4gYGV4cGVjdGBcbiAgLy8gd2UgZG9uJ3QgZ2V0IHRoaXMgYXMgc3RydWN0dXJlZCBkYXRhLCBidXQgd2hhdCB3ZSBnZXRcbiAgLy8gaXMgdXNlZnVsIGVub3VnaCB0byBtYWtlIGl0IGZvciBvdXJzZWx2ZXNcblxuICBtYXBBc3NlcnRpb25zKGZpbGVuYW1lOiBzdHJpbmcsIGFzc2VydGlvbnM6IEFycmF5PEZvcm1hdHRlZEFzc2VydGlvblJlc3VsdD4pOiBBcnJheTxUZXN0QXNzZXJ0aW9uU3RhdHVzPiB7XG4gICAgLy8gY29udmVydCBqZXN0IGxvY2F0aW9uIChjb2x1bW4gaXMgMC1iYXNlZCBhbmQgbGluZSBpcyAxLWJhc2VkKSB0byBhbGwgMC1iYXNlZCBsb2NhdGlvbiB1c2VkIGludGVybmFsbHkgaW4gdGhpcyBwYWNrYWdlXG4gICAgLyogZXNsaW50LWRpc2FibGUgbm8tcGFyYW0tcmVhc3NpZ24gKi9cbiAgICBjb25zdCBjb252ZXJ0SmVzdExvY2F0aW9uID0gKGplc3RMb2NhdGlvbjogP0xvY2F0aW9uKSA9PiB7XG4gICAgICBpZiAoamVzdExvY2F0aW9uKSB7XG4gICAgICAgIGplc3RMb2NhdGlvbi5saW5lIC09IDE7XG4gICAgICB9XG4gICAgICByZXR1cm4gamVzdExvY2F0aW9uO1xuICAgIH07XG4gICAgLy8gSXMgaXQgamVzdCA8IDE3PyBlLmcuIEJlZm9yZSBJIGFkZGVkIHRoaXMgdG8gdGhlIEpTT05cbiAgICBpZiAoIWFzc2VydGlvbnMpIHtcbiAgICAgIHJldHVybiBbXTtcbiAgICB9XG5cbiAgICAvLyBDaGFuZ2UgYWxsIGZhaWxpbmcgYXNzZXJ0aW9ucyBpbnRvIHN0cnVjdHVyZWQgZGF0YVxuICAgIHJldHVybiBhc3NlcnRpb25zLm1hcChhc3NlcnRpb24gPT4ge1xuICAgICAgLy8gRmFpbHVyZSBtZXNzYWdlcyBzZWVtcyB0byBhbHdheXMgYmUgYW4gYXJyYXkgb2Ygb25lIGl0ZW1cbiAgICAgIGNvbnN0IG1lc3NhZ2UgPSBhc3NlcnRpb24uZmFpbHVyZU1lc3NhZ2VzICYmIGFzc2VydGlvbi5mYWlsdXJlTWVzc2FnZXNbMF07XG4gICAgICBsZXQgc2hvcnQgPSBudWxsO1xuICAgICAgbGV0IHRlcnNlID0gbnVsbDtcbiAgICAgIGxldCBsaW5lID0gbnVsbDtcbiAgICAgIGNvbnN0IGxvY2F0aW9uID0gY29udmVydEplc3RMb2NhdGlvbihhc3NlcnRpb24ubG9jYXRpb24pOyAvLyBvdXRwdXQgZnJvbSBqZXN0IC0tdGVzdExvY2F0aW9uSW5SZXN1bHRzIChodHRwczovL2plc3Rqcy5pby9kb2NzL2VuL2NsaSN0ZXN0bG9jYXRpb25pbnJlc3VsdHMpXG4gICAgICBpZiAobWVzc2FnZSkge1xuICAgICAgICAvLyBKdXN0IHRoZSBmaXJzdCBsaW5lLCB3aXRoIGxpdHRsZSB3aGl0ZXNwYWNlXG4gICAgICAgIHNob3J0ID0gbWVzc2FnZS5zcGxpdCgnICAgYXQnLCAxKVswXS50cmltKCk7XG4gICAgICAgIC8vIHRoaXMgd2lsbCBzaG93IGlubGluZSwgc28gd2Ugd2FudCB0byBzaG93IHZlcnkgbGl0dGxlXG4gICAgICAgIHRlcnNlID0gdGhpcy5zYW5pdGl6ZVNob3J0RXJyb3JNZXNzYWdlKHNob3J0KTtcbiAgICAgICAgbGluZSA9IHRoaXMubGluZU9mRXJyb3IobWVzc2FnZSwgZmlsZW5hbWUpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgbGluZSxcbiAgICAgICAgbWVzc2FnZTogbWVzc2FnZSB8fCAnJyxcbiAgICAgICAgc2hvcnRNZXNzYWdlOiBzaG9ydCxcbiAgICAgICAgc3RhdHVzOiB0aGlzLnN0YXR1c1RvUmVjb25jaWxhdGlvblN0YXRlKGFzc2VydGlvbi5zdGF0dXMpLFxuICAgICAgICB0ZXJzZU1lc3NhZ2U6IHRlcnNlLFxuICAgICAgICB0aXRsZTogYXNzZXJ0aW9uLnRpdGxlLFxuICAgICAgICBsb2NhdGlvbixcbiAgICAgICAgZnVsbE5hbWU6IGFzc2VydGlvbi5mdWxsTmFtZSxcbiAgICAgICAgYW5jZXN0b3JUaXRsZXM6IGFzc2VydGlvbi5hbmNlc3RvclRpdGxlcyxcbiAgICAgIH07XG4gICAgfSk7XG4gIH1cblxuICAvLyBEbyBldmVyeXRoaW5nIHdlIGNhbiB0byB0cnkgbWFrZSBhIG9uZS1saW5lciBmcm9tIHRoZSBlcnJvciByZXBvcnRcbiAgc2FuaXRpemVTaG9ydEVycm9yTWVzc2FnZShzdHJpbmc6IHN0cmluZyk6IHN0cmluZyB7XG4gICAgaWYgKHN0cmluZy5pbmNsdWRlcygnZG9lcyBub3QgbWF0Y2ggc3RvcmVkIHNuYXBzaG90JykpIHtcbiAgICAgIHJldHVybiAnU25hcHNob3QgaGFzIGNoYW5nZWQnO1xuICAgIH1cblxuICAgIGlmIChzdHJpbmcuaW5jbHVkZXMoJ05ldyBzbmFwc2hvdCB3YXMgbm90IHdyaXR0ZW4nKSkge1xuICAgICAgcmV0dXJuICdOZXcgc25hcHNob3QgaXMgcmVhZHkgdG8gd3JpdGUnO1xuICAgIH1cblxuICAgIHJldHVybiBzdHJpbmdcbiAgICAgIC5zcGxpdCgnXFxuJylcbiAgICAgIC5zcGxpY2UoMilcbiAgICAgIC5qb2luKCcnKVxuICAgICAgLnJlcGxhY2UoL1xcc1xccysvZywgJyAnKVxuICAgICAgLnJlcGxhY2UoJ1JlY2VpdmVkOicsICcsIFJlY2VpdmVkOicpXG4gICAgICAuc3BsaXQoJ0RpZmZlcmVuY2U6JylbMF07XG4gIH1cblxuICAvLyBQdWxsIHRoZSBsaW5lIG91dCBmcm9tIHRoZSBzdGFjayB0cmFjZVxuICBsaW5lT2ZFcnJvcihtZXNzYWdlOiBzdHJpbmcsIGZpbGVQYXRoOiBzdHJpbmcpOiA/bnVtYmVyIHtcbiAgICBjb25zdCBmaWxlbmFtZSA9IHBhdGguYmFzZW5hbWUoZmlsZVBhdGgpO1xuICAgIGNvbnN0IHJlc3RPZlRyYWNlID0gbWVzc2FnZS5zcGxpdChmaWxlbmFtZSwgMilbMV07XG4gICAgcmV0dXJuIHJlc3RPZlRyYWNlID8gcGFyc2VJbnQocmVzdE9mVHJhY2Uuc3BsaXQoJzonKVsxXSwgMTApIDogbnVsbDtcbiAgfVxuXG4gIHN0YXR1c1RvUmVjb25jaWxhdGlvblN0YXRlKHN0YXR1czogc3RyaW5nKTogVGVzdFJlY29uY2lsaWF0aW9uU3RhdGUge1xuICAgIHN3aXRjaCAoc3RhdHVzKSB7XG4gICAgICBjYXNlICdwYXNzZWQnOlxuICAgICAgICByZXR1cm4gJ0tub3duU3VjY2Vzcyc7XG4gICAgICBjYXNlICdmYWlsZWQnOlxuICAgICAgICByZXR1cm4gJ0tub3duRmFpbCc7XG4gICAgICBjYXNlICdwZW5kaW5nJzpcbiAgICAgICAgcmV0dXJuICdLbm93blNraXAnO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuICdVbmtub3duJztcbiAgICB9XG4gIH1cblxuICBzdGF0ZUZvclRlc3RGaWxlKGZpbGU6IHN0cmluZyk6IFRlc3RSZWNvbmNpbGlhdGlvblN0YXRlIHtcbiAgICBjb25zdCByZXN1bHRzID0gdGhpcy5maWxlU3RhdHVzZXNbZmlsZV07XG4gICAgaWYgKCFyZXN1bHRzKSB7XG4gICAgICByZXR1cm4gJ1Vua25vd24nO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0cy5zdGF0dXM7XG4gIH1cblxuICBhc3NlcnRpb25zRm9yVGVzdEZpbGUoZmlsZTogc3RyaW5nKTogVGVzdEFzc2VydGlvblN0YXR1c1tdIHwgbnVsbCB7XG4gICAgY29uc3QgcmVzdWx0cyA9IHRoaXMuZmlsZVN0YXR1c2VzW2ZpbGVdO1xuICAgIHJldHVybiByZXN1bHRzID8gcmVzdWx0cy5hc3NlcnRpb25zIDogbnVsbDtcbiAgfVxuXG4gIHN0YXRlRm9yVGVzdEFzc2VydGlvbihmaWxlOiBzdHJpbmcsIG5hbWU6IHN0cmluZyk6IFRlc3RBc3NlcnRpb25TdGF0dXMgfCBudWxsIHtcbiAgICBjb25zdCByZXN1bHRzID0gdGhpcy5maWxlU3RhdHVzZXNbZmlsZV07XG4gICAgaWYgKCFyZXN1bHRzIHx8ICFyZXN1bHRzLmFzc2VydGlvbnMpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBjb25zdCBhc3NlcnRpb24gPSByZXN1bHRzLmFzc2VydGlvbnMuZmluZChhID0+IGEudGl0bGUgPT09IG5hbWUpO1xuICAgIGlmICghYXNzZXJ0aW9uKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIGFzc2VydGlvbjtcbiAgfVxufVxuIl19