"use strict";

function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

require("core-js/modules/es.symbol");

require("core-js/modules/es.symbol.description");

require("core-js/modules/es.symbol.iterator");

require("core-js/modules/es.array.concat");

require("core-js/modules/es.array.filter");

require("core-js/modules/es.array.for-each");

require("core-js/modules/es.array.from");

require("core-js/modules/es.array.is-array");

require("core-js/modules/es.array.iterator");

require("core-js/modules/es.array.reduce");

require("core-js/modules/es.array.slice");

require("core-js/modules/es.date.to-string");

require("core-js/modules/es.function.name");

require("core-js/modules/es.object.define-properties");

require("core-js/modules/es.object.define-property");

require("core-js/modules/es.object.get-own-property-descriptor");

require("core-js/modules/es.object.get-own-property-descriptors");

require("core-js/modules/es.object.keys");

require("core-js/modules/es.object.to-string");

require("core-js/modules/es.regexp.to-string");

require("core-js/modules/es.string.iterator");

require("core-js/modules/web.dom-collections.for-each");

require("core-js/modules/web.dom-collections.iterator");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.parseTs = exports.parseJs = exports.plugins = exports.parse = exports.getASTfor = exports.UNSUPPORTED_TEST_NAME = exports.UNRESOLVED_FUNCTION_NAME = void 0;

var _fs = require("fs");

var _types = require("@babel/types");

var parser = _interopRequireWildcard(require("@babel/parser"));

var _parser_nodes = require("./parser_nodes");

function _getRequireWildcardCache() { if (typeof WeakMap !== "function") return null; var cache = new WeakMap(); _getRequireWildcardCache = function _getRequireWildcardCache() { return cache; }; return cache; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || _typeof(obj) !== "object" && typeof obj !== "function") { return { "default": obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj["default"] = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function _iterableToArrayLimit(arr, i) { if (typeof Symbol === "undefined" || !(Symbol.iterator in Object(arr))) return; var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

var UNRESOLVED_FUNCTION_NAME = '__function__';
exports.UNRESOLVED_FUNCTION_NAME = UNRESOLVED_FUNCTION_NAME;
var UNSUPPORTED_TEST_NAME = '__unsupported__';
exports.UNSUPPORTED_TEST_NAME = UNSUPPORTED_TEST_NAME;

var _getASTfor = function _getASTfor(file, data, options) {
  var _data = data || (0, _fs.readFileSync)(file).toString();

  var config = _objectSpread(_objectSpread({}, options), {}, {
    sourceType: 'module'
  });

  return [parser.parse(_data, config), _data];
};

var getASTfor = function getASTfor(file, data) {
  var _getASTfor2 = _getASTfor(file, data),
      _getASTfor3 = _slicedToArray(_getASTfor2, 1),
      bFile = _getASTfor3[0];

  return bFile;
};

exports.getASTfor = getASTfor;

var parse = function parse(file, data, options) {
  var parseResult = new _parser_nodes.ParseResult(file);

  var _getASTfor4 = _getASTfor(file, data, options),
      _getASTfor5 = _slicedToArray(_getASTfor4, 2),
      ast = _getASTfor5[0],
      _data = _getASTfor5[1];

  var deepGet = function deepGet(node) {
    for (var _len = arguments.length, types = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      types[_key - 1] = arguments[_key];
    }

    return types.reduce(function (rootForType, type) {
      while (rootForType[type]) {
        rootForType = rootForType[type];
      }

      return rootForType;
    }, node);
  };

  var updateNameInfo = function updateNameInfo(nBlock, bNode) {
    var arg = bNode.expression.arguments[0];
    var name = arg.value;

    if (!name) {
      switch (arg.type) {
        case 'TemplateLiteral':
          name = _data.substring(arg.start + 1, arg.end - 1);
          break;

        case 'CallExpression':
          // a dynamic function: use a placeholder
          name = UNRESOLVED_FUNCTION_NAME;
          break;

        default:
          // eslint-disable-next-line no-console
          console.warn("failed to extract name for type \"".concat(arg.type, "\" in node:"), bNode);
          name = UNSUPPORTED_TEST_NAME;
          break;
      }
    }

    nBlock.name = name;
    nBlock.nameRange = new _parser_nodes.ParsedRange(arg.loc.start.line, arg.loc.start.column + 2, arg.loc.end.line, arg.loc.end.column - 1);
  };

  var updateNode = function updateNode(node, babylonNode) {
    node.start = babylonNode.loc.start;
    node.end = babylonNode.loc.end;
    node.start.column += 1;
    parseResult.addNode(node);

    if (node instanceof _parser_nodes.NamedBlock) {
      updateNameInfo(node, babylonNode);
    }
  };

  var isFunctionCall = function isFunctionCall(node) {
    return node && node.type === 'ExpressionStatement' && node.expression && node.expression.type === 'CallExpression';
  };

  var isFunctionDeclaration = function isFunctionDeclaration(nodeType) {
    return nodeType === 'ArrowFunctionExpression' || nodeType === 'FunctionExpression';
  }; // Pull out the name of a CallExpression (describe/it)


  var getNameForNode = function getNameForNode(node) {
    if (isFunctionCall(node) && node.expression.callee) {
      // Get root callee in case it's a chain of higher-order functions (e.g. .each(table)(name, fn))
      var rootCallee = deepGet(node.expression, 'callee');
      var name = rootCallee.name || // handle cases where it's a member expression (e.g .only or .concurrent.only)
      deepGet(rootCallee, 'object').name || // handle cases where it's part of a tag (e.g. .each`table`)
      deepGet(rootCallee, 'tag', 'object').name;
      return name;
    }

    return undefined;
  }; // When given a node in the AST, does this represent
  // the start of an it/test block?


  var isAnIt = function isAnIt(node) {
    var name = getNameForNode(node);
    return name === 'it' || name === 'fit' || name === 'test';
  };

  var isAnDescribe = function isAnDescribe(node) {
    var name = getNameForNode(node);
    return name === 'describe';
  }; // When given a node in the AST, does this represent
  // the start of an expect expression?


  var isAnExpect = function isAnExpect(node) {
    if (!isFunctionCall(node)) {
      return false;
    }

    var name = '';
    var element = node && node.expression ? node.expression.callee : undefined;

    while (!name && element) {
      // eslint-disable-next-line prefer-destructuring
      name = element.name; // Because expect may have accessors tacked on (.to.be) or nothing
      // (expect()) we have to check multiple levels for the name

      element = element.object || element.callee;
    }

    return name === 'expect';
  };

  var addNode = function addNode(type, parent, babylonNode) {
    var child = parent.addChild(type);
    updateNode(child, babylonNode);

    if (child instanceof _parser_nodes.NamedBlock && child.name == null) {
      // eslint-disable-next-line no-console
      console.warn("block is missing name: ".concat(JSON.stringify(babylonNode)));
    }

    return child;
  }; // A recursive AST parser


  var searchNodes = function searchNodes(babylonParent, parent) {
    // Look through the node's children
    var child;

    if (!babylonParent.body || !Array.isArray(babylonParent.body)) {
      return;
    }

    babylonParent.body.forEach(function (element) {
      var _element$argument;

      child = undefined; // Pull out the node
      // const element = babylonParent.body[node];

      if (isAnDescribe(element)) {
        child = addNode('describe', parent, element);
      } else if (isAnIt(element)) {
        child = addNode('it', parent, element);
      } else if (isAnExpect(element)) {
        child = addNode('expect', parent, element);
      } else if (element && element.type === 'VariableDeclaration') {
        element.declarations.filter(function (declaration) {
          return declaration.init && isFunctionDeclaration(declaration.init.type);
        }).forEach(function (declaration) {
          return searchNodes(declaration.init.body, parent);
        });
      } else if (element && element.type === 'ExpressionStatement' && element.expression && element.expression.type === 'AssignmentExpression' && element.expression.right && isFunctionDeclaration(element.expression.right.type)) {
        searchNodes(element.expression.right.body, parent);
      } else if (element.type === 'ReturnStatement' && ((_element$argument = element.argument) === null || _element$argument === void 0 ? void 0 : _element$argument.arguments)) {
        element.argument.arguments.filter(function (argument) {
          return isFunctionDeclaration(argument.type);
        }).forEach(function (argument) {
          return searchNodes(argument.body, parent);
        });
      }

      if (isFunctionCall(element)) {
        element.expression.arguments.filter(function (argument) {
          return isFunctionDeclaration(argument.type);
        }).forEach(function (argument) {
          return searchNodes(argument.body, child || parent);
        });
      }
    });
  };

  var program = ast.program;
  searchNodes(program, parseResult.root);
  return parseResult;
};

exports.parse = parse;
var plugins = ['asyncGenerators', 'bigInt', 'classPrivateMethods', 'classPrivateProperties', 'classProperties', 'doExpressions', 'dynamicImport', 'estree', 'exportDefaultFrom', 'exportNamespaceFrom', // deprecated
'functionBind', 'functionSent', 'importMeta', 'jsx', 'logicalAssignment', 'nullishCoalescingOperator', 'numericSeparator', 'objectRestSpread', 'optionalCatchBinding', 'optionalChaining', 'partialApplication', 'throwExpressions', 'topLevelAwait', ['decorators', {
  decoratorsBeforeExport: true
}], ['pipelineOperator', {
  proposal: 'smart'
}]]; // Its not possible to use the parser with flow and typescript active at the same time

exports.plugins = plugins;

var parseJs = function parseJs(file, data) {
  return parse(file, data, {
    plugins: [].concat(plugins, ['flow'])
  });
};

exports.parseJs = parseJs;

var parseTs = function parseTs(file, data) {
  return parse(file, data, {
    plugins: [].concat(plugins, ['typescript'])
  });
};

exports.parseTs = parseTs;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9wYXJzZXJzL2JhYmVsX3BhcnNlci5qcyJdLCJuYW1lcyI6WyJVTlJFU09MVkVEX0ZVTkNUSU9OX05BTUUiLCJVTlNVUFBPUlRFRF9URVNUX05BTUUiLCJfZ2V0QVNUZm9yIiwiZmlsZSIsImRhdGEiLCJvcHRpb25zIiwiX2RhdGEiLCJ0b1N0cmluZyIsImNvbmZpZyIsInNvdXJjZVR5cGUiLCJwYXJzZXIiLCJwYXJzZSIsImdldEFTVGZvciIsImJGaWxlIiwicGFyc2VSZXN1bHQiLCJQYXJzZVJlc3VsdCIsImFzdCIsImRlZXBHZXQiLCJub2RlIiwidHlwZXMiLCJyZWR1Y2UiLCJyb290Rm9yVHlwZSIsInR5cGUiLCJ1cGRhdGVOYW1lSW5mbyIsIm5CbG9jayIsImJOb2RlIiwiYXJnIiwiZXhwcmVzc2lvbiIsImFyZ3VtZW50cyIsIm5hbWUiLCJ2YWx1ZSIsInN1YnN0cmluZyIsInN0YXJ0IiwiZW5kIiwiY29uc29sZSIsIndhcm4iLCJuYW1lUmFuZ2UiLCJQYXJzZWRSYW5nZSIsImxvYyIsImxpbmUiLCJjb2x1bW4iLCJ1cGRhdGVOb2RlIiwiYmFieWxvbk5vZGUiLCJhZGROb2RlIiwiTmFtZWRCbG9jayIsImlzRnVuY3Rpb25DYWxsIiwiaXNGdW5jdGlvbkRlY2xhcmF0aW9uIiwibm9kZVR5cGUiLCJnZXROYW1lRm9yTm9kZSIsImNhbGxlZSIsInJvb3RDYWxsZWUiLCJ1bmRlZmluZWQiLCJpc0FuSXQiLCJpc0FuRGVzY3JpYmUiLCJpc0FuRXhwZWN0IiwiZWxlbWVudCIsIm9iamVjdCIsInBhcmVudCIsImNoaWxkIiwiYWRkQ2hpbGQiLCJKU09OIiwic3RyaW5naWZ5Iiwic2VhcmNoTm9kZXMiLCJiYWJ5bG9uUGFyZW50IiwiYm9keSIsIkFycmF5IiwiaXNBcnJheSIsImZvckVhY2giLCJkZWNsYXJhdGlvbnMiLCJmaWx0ZXIiLCJkZWNsYXJhdGlvbiIsImluaXQiLCJyaWdodCIsImFyZ3VtZW50IiwicHJvZ3JhbSIsInJvb3QiLCJwbHVnaW5zIiwiZGVjb3JhdG9yc0JlZm9yZUV4cG9ydCIsInByb3Bvc2FsIiwicGFyc2VKcyIsInBhcnNlVHMiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFXQTs7QUFDQTs7QUFDQTs7QUFFQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBRU8sSUFBTUEsd0JBQXdCLEdBQUcsY0FBakM7O0FBQ0EsSUFBTUMscUJBQXFCLEdBQUcsaUJBQTlCOzs7QUFFUCxJQUFNQyxVQUFVLEdBQUcsU0FBYkEsVUFBYSxDQUFDQyxJQUFELEVBQWVDLElBQWYsRUFBOEJDLE9BQTlCLEVBQXNGO0FBQ3ZHLE1BQU1DLEtBQUssR0FBR0YsSUFBSSxJQUFJLHNCQUFhRCxJQUFiLEVBQW1CSSxRQUFuQixFQUF0Qjs7QUFDQSxNQUFNQyxNQUFNLG1DQUFPSCxPQUFQO0FBQWdCSSxJQUFBQSxVQUFVLEVBQUU7QUFBNUIsSUFBWjs7QUFDQSxTQUFPLENBQUNDLE1BQU0sQ0FBQ0MsS0FBUCxDQUFhTCxLQUFiLEVBQW9CRSxNQUFwQixDQUFELEVBQThCRixLQUE5QixDQUFQO0FBQ0QsQ0FKRDs7QUFNTyxJQUFNTSxTQUFTLEdBQUcsU0FBWkEsU0FBWSxDQUFDVCxJQUFELEVBQWVDLElBQWYsRUFBNEM7QUFBQSxvQkFDbkRGLFVBQVUsQ0FBQ0MsSUFBRCxFQUFPQyxJQUFQLENBRHlDO0FBQUE7QUFBQSxNQUM1RFMsS0FENEQ7O0FBRW5FLFNBQU9BLEtBQVA7QUFDRCxDQUhNOzs7O0FBS0EsSUFBTUYsS0FBSyxHQUFHLFNBQVJBLEtBQVEsQ0FBQ1IsSUFBRCxFQUFlQyxJQUFmLEVBQThCQyxPQUE5QixFQUE4RTtBQUNqRyxNQUFNUyxXQUFXLEdBQUcsSUFBSUMseUJBQUosQ0FBZ0JaLElBQWhCLENBQXBCOztBQURpRyxvQkFFNUVELFVBQVUsQ0FBQ0MsSUFBRCxFQUFPQyxJQUFQLEVBQWFDLE9BQWIsQ0FGa0U7QUFBQTtBQUFBLE1BRTFGVyxHQUYwRjtB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QUEsU0FDckJPLEtBQUssQ0FBQ1IsSUFBRCxFQUFPQyxJQUFQLEVBQWE7QUFBQ3dFLElBQUFBLE9BQU8sWUFBTUEsT0FBTixHQUFlLFlBQWY7QUFBUixHQUFiLENBRGdCO0FBQUEsQ0FBaEIiLCJzb3VyY2VzQ29udGVudCI6WyIvKiBlc2xpbnQtZGlzYWJsZSBuby11bmRlcnNjb3JlLWRhbmdsZSAqL1xuLyogZXNsaW50LWRpc2FibGUgbm8tcGFyYW0tcmVhc3NpZ24gKi9cbi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDE0LXByZXNlbnQsIEZhY2Vib29rLCBJbmMuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKlxuICogQGZsb3dcbiAqL1xuXG5pbXBvcnQge3JlYWRGaWxlU3luY30gZnJvbSAnZnMnO1xuaW1wb3J0IHtGaWxlIGFzIEJhYmVsRmlsZSwgTm9kZSBhcyBCYWJlbE5vZGV9IGZyb20gJ0BiYWJlbC90eXBlcyc7XG5pbXBvcnQgKiBhcyBwYXJzZXIgZnJvbSAnQGJhYmVsL3BhcnNlcic7XG5pbXBvcnQgdHlwZSB7UGFyc2VkTm9kZVR5cGV9IGZyb20gJy4vcGFyc2VyX25vZGVzJztcbmltcG9ydCB7TmFtZWRCbG9jaywgUGFyc2VkUmFuZ2UsIFBhcnNlUmVzdWx0LCBQYXJzZWROb2RlfSBmcm9tICcuL3BhcnNlcl9ub2Rlcyc7XG5cbmV4cG9ydCBjb25zdCBVTlJFU09MVkVEX0ZVTkNUSU9OX05BTUUgPSAnX19mdW5jdGlvbl9fJztcbmV4cG9ydCBjb25zdCBVTlNVUFBPUlRFRF9URVNUX05BTUUgPSAnX191bnN1cHBvcnRlZF9fJztcblxuY29uc3QgX2dldEFTVGZvciA9IChmaWxlOiBzdHJpbmcsIGRhdGE6ID9zdHJpbmcsIG9wdGlvbnM6ID9wYXJzZXIuUGFyc2VyT3B0aW9ucyk6IFtCYWJlbEZpbGUsIHN0cmluZ10gPT4ge1xuICBjb25zdCBfZGF0YSA9IGRhdGEgfHwgcmVhZEZpbGVTeW5jKGZpbGUpLnRvU3RyaW5nKCk7XG4gIGNvbnN0IGNvbmZpZyA9IHsuLi5vcHRpb25zLCBzb3VyY2VUeXBlOiAnbW9kdWxlJ307XG4gIHJldHVybiBbcGFyc2VyLnBhcnNlKF9kYXRhLCBjb25maWcpLCBfZGF0YV07XG59O1xuXG5leHBvcnQgY29uc3QgZ2V0QVNUZm9yID0gKGZpbGU6IHN0cmluZywgZGF0YTogP3N0cmluZyk6IEJhYmVsRmlsZSA9PiB7XG4gIGNvbnN0IFtiRmlsZV0gPSBfZ2V0QVNUZm9yKGZpbGUsIGRhdGEpO1xuICByZXR1cm4gYkZpbGU7XG59O1xuXG5leHBvcnQgY29uc3QgcGFyc2UgPSAoZmlsZTogc3RyaW5nLCBkYXRhOiA/c3RyaW5nLCBvcHRpb25zOiA/cGFyc2VyLlBhcnNlck9wdGlvbnMpOiBQYXJzZVJlc3VsdCA9PiB7XG4gIGNvbnN0IHBhcnNlUmVzdWx0ID0gbmV3IFBhcnNlUmVzdWx0KGZpbGUpO1xuICBjb25zdCBbYXN0LCBfZGF0YV0gPSBfZ2V0QVNUZm9yKGZpbGUsIGRhdGEsIG9wdGlvbnMpO1xuXG4gIGNvbnN0IGRlZXBHZXQgPSAobm9kZSwgLi4udHlwZXM6IHN0cmluZ1tdKSA9PlxuICAgIHR5cGVzLnJlZHVjZTxCYWJlbE5vZGU+KChyb290Rm9yVHlwZSwgdHlwZSkgPT4ge1xuICAgICAgd2hpbGUgKHJvb3RGb3JUeXBlW3R5cGVdKSB7XG4gICAgICAgIHJvb3RGb3JUeXBlID0gcm9vdEZvclR5cGVbdHlwZV07XG4gICAgICB9XG4gICAgICByZXR1cm4gcm9vdEZvclR5cGU7XG4gICAgfSwgbm9kZSk7XG5cbiAgY29uc3QgdXBkYXRlTmFtZUluZm8gPSAobkJsb2NrOiBOYW1lZEJsb2NrLCBiTm9kZTogQmFiZWxOb2RlKSA9PiB7XG4gICAgY29uc3QgYXJnID0gYk5vZGUuZXhwcmVzc2lvbi5hcmd1bWVudHNbMF07XG4gICAgbGV0IG5hbWUgPSBhcmcudmFsdWU7XG5cbiAgICBpZiAoIW5hbWUpIHtcbiAgICAgIHN3aXRjaCAoYXJnLnR5cGUpIHtcbiAgICAgICAgY2FzZSAnVGVtcGxhdGVMaXRlcmFsJzpcbiAgICAgICAgICBuYW1lID0gX2RhdGEuc3Vic3RyaW5nKGFyZy5zdGFydCArIDEsIGFyZy5lbmQgLSAxKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnQ2FsbEV4cHJlc3Npb24nOlxuICAgICAgICAgIC8vIGEgZHluYW1pYyBmdW5jdGlvbjogdXNlIGEgcGxhY2Vob2xkZXJcbiAgICAgICAgICBuYW1lID0gVU5SRVNPTFZFRF9GVU5DVElPTl9OQU1FO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1jb25zb2xlXG4gICAgICAgICAgY29uc29sZS53YXJuKGBmYWlsZWQgdG8gZXh0cmFjdCBuYW1lIGZvciB0eXBlIFwiJHthcmcudHlwZX1cIiBpbiBub2RlOmAsIGJOb2RlKTtcbiAgICAgICAgICBuYW1lID0gVU5TVVBQT1JURURfVEVTVF9OQU1FO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cblxuICAgIG5CbG9jay5uYW1lID0gbmFtZTtcbiAgICBuQmxvY2submFtZVJhbmdlID0gbmV3IFBhcnNlZFJhbmdlKFxuICAgICAgYXJnLmxvYy5zdGFydC5saW5lLFxuICAgICAgYXJnLmxvYy5zdGFydC5jb2x1bW4gKyAyLFxuICAgICAgYXJnLmxvYy5lbmQubGluZSxcbiAgICAgIGFyZy5sb2MuZW5kLmNvbHVtbiAtIDFcbiAgICApO1xuICB9O1xuXG4gIGNvbnN0IHVwZGF0ZU5vZGUgPSAobm9kZTogUGFyc2VkTm9kZSwgYmFieWxvbk5vZGU6IEJhYmVsTm9kZSkgPT4ge1xuICAgIG5vZGUuc3RhcnQgPSBiYWJ5bG9uTm9kZS5sb2Muc3RhcnQ7XG4gICAgbm9kZS5lbmQgPSBiYWJ5bG9uTm9kZS5sb2MuZW5kO1xuICAgIG5vZGUuc3RhcnQuY29sdW1uICs9IDE7XG5cbiAgICBwYXJzZVJlc3VsdC5hZGROb2RlKG5vZGUpO1xuICAgIGlmIChub2RlIGluc3RhbmNlb2YgTmFtZWRCbG9jaykge1xuICAgICAgdXBkYXRlTmFtZUluZm8obm9kZSwgYmFieWxvbk5vZGUpO1xuICAgIH1cbiAgfTtcblxuICBjb25zdCBpc0Z1bmN0aW9uQ2FsbCA9IG5vZGUgPT5cbiAgICBub2RlICYmIG5vZGUudHlwZSA9PT0gJ0V4cHJlc3Npb25TdGF0ZW1lbnQnICYmIG5vZGUuZXhwcmVzc2lvbiAmJiBub2RlLmV4cHJlc3Npb24udHlwZSA9PT0gJ0NhbGxFeHByZXNzaW9uJztcblxuICBjb25zdCBpc0Z1bmN0aW9uRGVjbGFyYXRpb24gPSAobm9kZVR5cGU6IHN0cmluZykgPT5cbiAgICBub2RlVHlwZSA9PT0gJ0Fycm93RnVuY3Rpb25FeHByZXNzaW9uJyB8fCBub2RlVHlwZSA9PT0gJ0Z1bmN0aW9uRXhwcmVzc2lvbic7XG5cbiAgLy8gUHVsbCBvdXQgdGhlIG5hbWUgb2YgYSBDYWxsRXhwcmVzc2lvbiAoZGVzY3JpYmUvaXQpXG4gIGNvbnN0IGdldE5hbWVGb3JOb2RlID0gbm9kZSA9PiB7XG4gICAgaWYgKGlzRnVuY3Rpb25DYWxsKG5vZGUpICYmIG5vZGUuZXhwcmVzc2lvbi5jYWxsZWUpIHtcbiAgICAgIC8vIEdldCByb290IGNhbGxlZSBpbiBjYXNlIGl0J3MgYSBjaGFpbiBvZiBoaWdoZXItb3JkZXIgZnVuY3Rpb25zIChlLmcuIC5lYWNoKHRhYmxlKShuYW1lLCBmbikpXG4gICAgICBjb25zdCByb290Q2FsbGVlID0gZGVlcEdldChub2RlLmV4cHJlc3Npb24sICdjYWxsZWUnKTtcbiAgICAgIGNvbnN0IG5hbWUgPVxuICAgICAgICByb290Q2FsbGVlLm5hbWUgfHxcbiAgICAgICAgLy8gaGFuZGxlIGNhc2VzIHdoZXJlIGl0J3MgYSBtZW1iZXIgZXhwcmVzc2lvbiAoZS5nIC5vbmx5IG9yIC5jb25jdXJyZW50Lm9ubHkpXG4gICAgICAgIGRlZXBHZXQocm9vdENhbGxlZSwgJ29iamVjdCcpLm5hbWUgfHxcbiAgICAgICAgLy8gaGFuZGxlIGNhc2VzIHdoZXJlIGl0J3MgcGFydCBvZiBhIHRhZyAoZS5nLiAuZWFjaGB0YWJsZWApXG4gICAgICAgIGRlZXBHZXQocm9vdENhbGxlZSwgJ3RhZycsICdvYmplY3QnKS5uYW1lO1xuXG4gICAgICByZXR1cm4gbmFtZTtcbiAgICB9XG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgfTtcblxuICAvLyBXaGVuIGdpdmVuIGEgbm9kZSBpbiB0aGUgQVNULCBkb2VzIHRoaXMgcmVwcmVzZW50XG4gIC8vIHRoZSBzdGFydCBvZiBhbiBpdC90ZXN0IGJsb2NrP1xuICBjb25zdCBpc0FuSXQgPSBub2RlID0+IHtcbiAgICBjb25zdCBuYW1lID0gZ2V0TmFtZUZvck5vZGUobm9kZSk7XG4gICAgcmV0dXJuIG5hbWUgPT09ICdpdCcgfHwgbmFtZSA9PT0gJ2ZpdCcgfHwgbmFtZSA9PT0gJ3Rlc3QnO1xuICB9O1xuXG4gIGNvbnN0IGlzQW5EZXNjcmliZSA9IG5vZGUgPT4ge1xuICAgIGNvbnN0IG5hbWUgPSBnZXROYW1lRm9yTm9kZShub2RlKTtcbiAgICByZXR1cm4gbmFtZSA9PT0gJ2Rlc2NyaWJlJztcbiAgfTtcblxuICAvLyBXaGVuIGdpdmVuIGEgbm9kZSBpbiB0aGUgQVNULCBkb2VzIHRoaXMgcmVwcmVzZW50XG4gIC8vIHRoZSBzdGFydCBvZiBhbiBleHBlY3QgZXhwcmVzc2lvbj9cbiAgY29uc3QgaXNBbkV4cGVjdCA9IG5vZGUgPT4ge1xuICAgIGlmICghaXNGdW5jdGlvbkNhbGwobm9kZSkpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgbGV0IG5hbWUgPSAnJztcbiAgICBsZXQgZWxlbWVudCA9IG5vZGUgJiYgbm9kZS5leHByZXNzaW9uID8gbm9kZS5leHByZXNzaW9uLmNhbGxlZSA6IHVuZGVmaW5lZDtcbiAgICB3aGlsZSAoIW5hbWUgJiYgZWxlbWVudCkge1xuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHByZWZlci1kZXN0cnVjdHVyaW5nXG4gICAgICBuYW1lID0gZWxlbWVudC5uYW1lO1xuICAgICAgLy8gQmVjYXVzZSBleHBlY3QgbWF5IGhhdmUgYWNjZXNzb3JzIHRhY2tlZCBvbiAoLnRvLmJlKSBvciBub3RoaW5nXG4gICAgICAvLyAoZXhwZWN0KCkpIHdlIGhhdmUgdG8gY2hlY2sgbXVsdGlwbGUgbGV2ZWxzIGZvciB0aGUgbmFtZVxuICAgICAgZWxlbWVudCA9IGVsZW1lbnQub2JqZWN0IHx8IGVsZW1lbnQuY2FsbGVlO1xuICAgIH1cbiAgICByZXR1cm4gbmFtZSA9PT0gJ2V4cGVjdCc7XG4gIH07XG5cbiAgY29uc3QgYWRkTm9kZSA9ICh0eXBlOiBQYXJzZWROb2RlVHlwZSwgcGFyZW50OiBQYXJzZWROb2RlLCBiYWJ5bG9uTm9kZTogQmFiZWxOb2RlKTogUGFyc2VkTm9kZSA9PiB7XG4gICAgY29uc3QgY2hpbGQgPSBwYXJlbnQuYWRkQ2hpbGQodHlwZSk7XG4gICAgdXBkYXRlTm9kZShjaGlsZCwgYmFieWxvbk5vZGUpO1xuXG4gICAgaWYgKGNoaWxkIGluc3RhbmNlb2YgTmFtZWRCbG9jayAmJiBjaGlsZC5uYW1lID09IG51bGwpIHtcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1jb25zb2xlXG4gICAgICBjb25zb2xlLndhcm4oYGJsb2NrIGlzIG1pc3NpbmcgbmFtZTogJHtKU09OLnN0cmluZ2lmeShiYWJ5bG9uTm9kZSl9YCk7XG4gICAgfVxuICAgIHJldHVybiBjaGlsZDtcbiAgfTtcblxuICAvLyBBIHJlY3Vyc2l2ZSBBU1QgcGFyc2VyXG4gIGNvbnN0IHNlYXJjaE5vZGVzID0gKGJhYnlsb25QYXJlbnQ6IEJhYmVsTm9kZSwgcGFyZW50OiBQYXJzZWROb2RlKSA9PiB7XG4gICAgLy8gTG9vayB0aHJvdWdoIHRoZSBub2RlJ3MgY2hpbGRyZW5cbiAgICBsZXQgY2hpbGQ6ID9QYXJzZWROb2RlO1xuXG4gICAgaWYgKCFiYWJ5bG9uUGFyZW50LmJvZHkgfHwgIUFycmF5LmlzQXJyYXkoYmFieWxvblBhcmVudC5ib2R5KSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGJhYnlsb25QYXJlbnQuYm9keS5mb3JFYWNoKGVsZW1lbnQgPT4ge1xuICAgICAgY2hpbGQgPSB1bmRlZmluZWQ7XG4gICAgICAvLyBQdWxsIG91dCB0aGUgbm9kZVxuICAgICAgLy8gY29uc3QgZWxlbWVudCA9IGJhYnlsb25QYXJlbnQuYm9keVtub2RlXTtcblxuICAgICAgaWYgKGlzQW5EZXNjcmliZShlbGVtZW50KSkge1xuICAgICAgICBjaGlsZCA9IGFkZE5vZGUoJ2Rlc2NyaWJlJywgcGFyZW50LCBlbGVtZW50KTtcbiAgICAgIH0gZWxzZSBpZiAoaXNBbkl0KGVsZW1lbnQpKSB7XG4gICAgICAgIGNoaWxkID0gYWRkTm9kZSgnaXQnLCBwYXJlbnQsIGVsZW1lbnQpO1xuICAgICAgfSBlbHNlIGlmIChpc0FuRXhwZWN0KGVsZW1lbnQpKSB7XG4gICAgICAgIGNoaWxkID0gYWRkTm9kZSgnZXhwZWN0JywgcGFyZW50LCBlbGVtZW50KTtcbiAgICAgIH0gZWxzZSBpZiAoZWxlbWVudCAmJiBlbGVtZW50LnR5cGUgPT09ICdWYXJpYWJsZURlY2xhcmF0aW9uJykge1xuICAgICAgICBlbGVtZW50LmRlY2xhcmF0aW9uc1xuICAgICAgICAgIC5maWx0ZXIoZGVjbGFyYXRpb24gPT4gZGVjbGFyYXRpb24uaW5pdCAmJiBpc0Z1bmN0aW9uRGVjbGFyYXRpb24oZGVjbGFyYXRpb24uaW5pdC50eXBlKSlcbiAgICAgICAgICAuZm9yRWFjaChkZWNsYXJhdGlvbiA9PiBzZWFyY2hOb2RlcyhkZWNsYXJhdGlvbi5pbml0LmJvZHksIHBhcmVudCkpO1xuICAgICAgfSBlbHNlIGlmIChcbiAgICAgICAgZWxlbWVudCAmJlxuICAgICAgICBlbGVtZW50LnR5cGUgPT09ICdFeHByZXNzaW9uU3RhdGVtZW50JyAmJlxuICAgICAgICBlbGVtZW50LmV4cHJlc3Npb24gJiZcbiAgICAgICAgZWxlbWVudC5leHByZXNzaW9uLnR5cGUgPT09ICdBc3NpZ25tZW50RXhwcmVzc2lvbicgJiZcbiAgICAgICAgZWxlbWVudC5leHByZXNzaW9uLnJpZ2h0ICYmXG4gICAgICAgIGlzRnVuY3Rpb25EZWNsYXJhdGlvbihlbGVtZW50LmV4cHJlc3Npb24ucmlnaHQudHlwZSlcbiAgICAgICkge1xuICAgICAgICBzZWFyY2hOb2RlcyhlbGVtZW50LmV4cHJlc3Npb24ucmlnaHQuYm9keSwgcGFyZW50KTtcbiAgICAgIH0gZWxzZSBpZiAoZWxlbWVudC50eXBlID09PSAnUmV0dXJuU3RhdGVtZW50JyAmJiBlbGVtZW50LmFyZ3VtZW50Py5hcmd1bWVudHMpIHtcbiAgICAgICAgZWxlbWVudC5hcmd1bWVudC5hcmd1bWVudHNcbiAgICAgICAgICAuZmlsdGVyKGFyZ3VtZW50ID0+IGlzRnVuY3Rpb25EZWNsYXJhdGlvbihhcmd1bWVudC50eXBlKSlcbiAgICAgICAgICAuZm9yRWFjaChhcmd1bWVudCA9PiBzZWFyY2hOb2Rlcyhhcmd1bWVudC5ib2R5LCBwYXJlbnQpKTtcbiAgICAgIH1cblxuICAgICAgaWYgKGlzRnVuY3Rpb25DYWxsKGVsZW1lbnQpKSB7XG4gICAgICAgIGVsZW1lbnQuZXhwcmVzc2lvbi5hcmd1bWVudHNcbiAgICAgICAgICAuZmlsdGVyKGFyZ3VtZW50ID0+IGlzRnVuY3Rpb25EZWNsYXJhdGlvbihhcmd1bWVudC50eXBlKSlcbiAgICAgICAgICAuZm9yRWFjaChhcmd1bWVudCA9PiBzZWFyY2hOb2Rlcyhhcmd1bWVudC5ib2R5LCBjaGlsZCB8fCBwYXJlbnQpKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfTtcblxuICBjb25zdCB7cHJvZ3JhbX0gPSBhc3Q7XG4gIHNlYXJjaE5vZGVzKHByb2dyYW0sIHBhcnNlUmVzdWx0LnJvb3QpO1xuXG4gIHJldHVybiBwYXJzZVJlc3VsdDtcbn07XG5cbmV4cG9ydCBjb25zdCBwbHVnaW5zID0gW1xuICAnYXN5bmNHZW5lcmF0b3JzJyxcbiAgJ2JpZ0ludCcsXG4gICdjbGFzc1ByaXZhdGVNZXRob2RzJyxcbiAgJ2NsYXNzUHJpdmF0ZVByb3BlcnRpZXMnLFxuICAnY2xhc3NQcm9wZXJ0aWVzJyxcbiAgJ2RvRXhwcmVzc2lvbnMnLFxuICAnZHluYW1pY0ltcG9ydCcsXG4gICdlc3RyZWUnLFxuICAnZXhwb3J0RGVmYXVsdEZyb20nLFxuICAnZXhwb3J0TmFtZXNwYWNlRnJvbScsIC8vIGRlcHJlY2F0ZWRcbiAgJ2Z1bmN0aW9uQmluZCcsXG4gICdmdW5jdGlvblNlbnQnLFxuICAnaW1wb3J0TWV0YScsXG4gICdqc3gnLFxuICAnbG9naWNhbEFzc2lnbm1lbnQnLFxuICAnbnVsbGlzaENvYWxlc2NpbmdPcGVyYXRvcicsXG4gICdudW1lcmljU2VwYXJhdG9yJyxcbiAgJ29iamVjdFJlc3RTcHJlYWQnLFxuICAnb3B0aW9uYWxDYXRjaEJpbmRpbmcnLFxuICAnb3B0aW9uYWxDaGFpbmluZycsXG4gICdwYXJ0aWFsQXBwbGljYXRpb24nLFxuICAndGhyb3dFeHByZXNzaW9ucycsXG4gICd0b3BMZXZlbEF3YWl0JyxcbiAgWydkZWNvcmF0b3JzJywge2RlY29yYXRvcnNCZWZvcmVFeHBvcnQ6IHRydWV9XSxcbiAgWydwaXBlbGluZU9wZXJhdG9yJywge3Byb3Bvc2FsOiAnc21hcnQnfV0sXG5dO1xuXG4vLyBJdHMgbm90IHBvc3NpYmxlIHRvIHVzZSB0aGUgcGFyc2VyIHdpdGggZmxvdyBhbmQgdHlwZXNjcmlwdCBhY3RpdmUgYXQgdGhlIHNhbWUgdGltZVxuZXhwb3J0IGNvbnN0IHBhcnNlSnMgPSAoZmlsZTogc3RyaW5nLCBkYXRhOiA/c3RyaW5nKTogUGFyc2VSZXN1bHQgPT4gcGFyc2UoZmlsZSwgZGF0YSwge3BsdWdpbnM6IFsuLi5wbHVnaW5zLCAnZmxvdyddfSk7XG5leHBvcnQgY29uc3QgcGFyc2VUcyA9IChmaWxlOiBzdHJpbmcsIGRhdGE6ID9zdHJpbmcpOiBQYXJzZVJlc3VsdCA9PlxuICBwYXJzZShmaWxlLCBkYXRhLCB7cGx1Z2luczogWy4uLnBsdWdpbnMsICd0eXBlc2NyaXB0J119KTtcbiJdfQ==